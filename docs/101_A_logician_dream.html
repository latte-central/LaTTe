<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>A Logician's Dream</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1  current"><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="latte.core.html"><div class="inner"><span>latte.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#a-logicians-dream" id="a-logicians-dream"></a>A Logician’s Dream</h1>
<p>Mathematical logic is concerned with the formal specification and reasoning about mathematical content. A proof assistant, such as LaTTe, can be seen as an implementation of a mathematical logic on a computer.</p>
<h2><a href="#on-mathematical-content" id="on-mathematical-content"></a>On mathematical content</h2>
<p>LaTTe supports four main forms of  <em>mathematical content</em>:</p>
<ul>
<li>
<p><strong>definitions</strong> of mathematical concepts,</p>
</li>
<li>
<p>statements of <strong>axioms</strong> asserting fundamental properties of defined concepts,</p>
</li>
<li>
<p>statements of <strong>theorems</strong> asserting expected logical properties of defined concepts,</p>
</li>
<li>
<p>together with their <strong>proofs</strong>: certificates that the theorems are, indeed, true,</p>
</li>
</ul>
<p>(LaTTe also supports the notion of <strong>specials</strong> that cannot really be assimilated to mathematical content, but rather as a bridge between mathematics and informatics).</p>
<p>An example of a <strong>definition</strong> is the notion of a surjective function:</p>
<blockquote>
<p>A function F:T-&gt;U is <strong>surjective</strong> if forall y in U, exists x in T such that (F x) = y.</p>
</blockquote>
<p>In LaTTe this is defined as <a href="null">latte.rel/surjective</a>, which we reproduce below :</p>
<pre><code class="language-clojure">(definition surjective
  "A surjective function."
  [[T :type] [U :type] [F (==&gt; T U)]]
  (forall [y U] (exist [x T] (equal U (F x) y))))
</code></pre>
<p>Apart from being more formal, the LaTTe definition appears as quite faithful to the common definition (and important difference is the use of types and not (directly) sets, which will be discussed below).</p>
<p>An example of an <strong>axiom</strong> (namely of Peano arithmetics) follows:</p>
<blockquote>
<p>The successor function on integers is bijective.</p>
</blockquote>
<p>In LaTTe such an axiom can be stated as follows:</p>
<pre><code class="language-clojure">(defaxiom succ-bijective
  "The successor function is bijective."
  []
  (rel/bijective int int succ))
</code></pre>
<p>(cf. <a href="null">latte.rel/bijective</a>)</p>
<p>Based on a set of basic axioms and defined concepts, the working mathematician’s routine is to state theorems and provide proofs of such theorems. This is also, of course, the routine of the LaTTe used.</p>
<p>Here is an example of a theorem:</p>
<blockquote>
<p>The successor function is surjective.</p>
</blockquote>
<p>This is stated as follows in LaTTe:</p>
<pre><code class="language-clojure">(defthm succ-surjective
  "The successor function is surjective."
  []
  (rel/surjective int int succ))
</code></pre>
<p>The proof for this theorem is of course trivial.</p>
<blockquote>
<p>We now by an axiom that the successor function is bijective, hence it is also surjective (and injective). Qed.</p>
</blockquote>
<p>In LaTTe, this simple proof can also be expressed, e.g. as follows:</p>
<pre><code class="language-clojure">(proof succ-surjective :term
  ((rel/bijective-is-surjective int int succ) succ-bijective))
</code></pre>
<p>This can be interpred as follows:</p>
<blockquote>
<p>The proof of the theorem <a href="null">latte.rel/bijective-is-surjective</a> is a function that takes some <code>proof-of-bijection-for-...</code> as a parameter, and deduces that this <code>proof-of-bijection-for-...</code> is also a <code>proof-of-surjection-for-...</code>. This proof is applied to the axiom <code>succ-bijective</code> to yield the expected result.</p>
</blockquote>
<p>The last form of mathematical content available is a notion of a library, book or theory, allowing to regroup a set of definitions, axioms, theorems and proofs under a common name (e.g. <em>group theory</em>, <em>graph theory</em>, etc.). Latte here only exploit the Clojure programming environment, where the primary feature is called a namespace (but there is also a powerful notion of deployable library based on the JVM ecosystem).</p>
<h2><a href="#the-mathematical-notation" id="the-mathematical-notation"></a>The mathematical notation</h2>
<p>During the centuries of the development of mathematics, a complex (more or less) formal notation has been developped.</p>
<p>Advantage: all the mathematical literature is based on this notation</p>
<p>Drawback: it is not completely formal, and its support on a computer is difficult</p>
<p>A primary functionality of a proof assistant is to encode mathematical content so that it is “understood” by the computer. Many proof assistant accept a language very close to the common mathematical notation. It cannot be the same because many ambiguities and such must be solved to match the level of formality required by a computing environment. This is the infamous <em>parsing</em> problem, which is in fact a difficult problem.</p>
<p>A clearly controversial but totally assumed choice of LaTTe is to adopt a programming language notation instead of a mathematical one. The immediate advantage is that the parsing problem becomes trivial, it is performed by the programming language itself ! This is the Lisp way of seing things, which is conveyed (and improved) by the Clojure language.</p>
<p>TODO exemple en maths, équivalent en LaTTe.</p>
<h2><a href="#informal-vs-formal-reasoning" id="informal-vs-formal-reasoning"></a>Informal vs. formal reasoning</h2>
<p>The language of mathematics is highly codified and makes use of many symbols, but it is still mostly informal. In a way, the language used for describing and reasoning about the obviously highly formal concepts of mathematics is itself rather … informal. Mathematical logics aims at a better, more formal, notion of “a language of mathematics”. If philosophers approached this problem already centuries ago, the most important developments had to wait for a sufficent development of mathematics itself. Here follow some important events, dates and people involved in the problematic.</p>
<ul>
<li>boole</li>
<li>cantor</li>
<li>fregge</li>
<li>principia mathematica</li>
<li>zermelo frankael and set theory</li>
<li>Church lambda-calculus and theory of types</li>
<li>Curry-Howard, Per Martin Lof</li>
<li>LCF</li>
<li>System F (Girard/Reynolds)</li>
<li>Calculus of Constructions (Coquand/Huet)</li>
</ul>
<p>LaTTe is, similarly to other proof assitants, a computer-based environment for formalizing and reasoning about mathematical content. It is thus an answer to the problem at hand, and a particularly good answer in that it is difficult to be more formal (and stubborn) than a computer !</p>
<p>Technically-speaking, LaTTe implements a lambda-calculus that is close to the calculus of constructions.  It is more precisely a variant of <em>lambdaD</em> (as defined in the book <em>Type Theory and Formal Proofs</em>), i.e. a variant of the calculus of constructions extended with definitional features.</p>
<p>There is still some place for informalities:</p>
<ul>
<li>
<p>the explanations around the formal definitions and proofs,</p>
</li>
<li>
<p>the justification of the axioms</p>
</li>
</ul>
<p>The latter is such an important aspect that it is the thema of the next section.</p>
<h2><a href="#axioms-vs-theorems" id="axioms-vs-theorems"></a>Axioms vs. Theorems</h2>
<p>There is a centuries-long debate about the acceptance or rejection of <em>axioms</em> in many mathematical theories. Some axioms are clearly beyond discussion (e.g. the axioms of ZF set theory, the axioms of Peano arithmetics, etc.) and some axioms are (still) heavily debated (choice or not choice, classical or not, cf. below, etc.). Introducing an axiom should thus be a very careful decision, and most importantly, it must be justified by a mathematical (if not philosophical) argument.</p>
<p>This is a first important distinction between an axiom and a theorem:</p>
<ul>
<li>
<p>an axiom is justified by an informal mathematical/philosophical argument</p>
</li>
<li>
<p>a theorem is justified by a formal proof</p>
</li>
</ul>
<p>Using LaTTe, nothing prevents the replacement of all theorems by corresponding axioms. In fact, we can simply replace <code>defthm</code> (definition of a theorem) by <code>defaxiom</code> and remove all the proofs. However, what we end up with is not very satisfying.</p>
<ul>
<li>
<p>an axiom can introduce an inconsistencies, whereas a theorem cannot</p>
</li>
<li>
<p>an axiom having no proof, having only axioms means there are no proofs anymore, hence we fail at the formalization of reasoning. There is no reasoning anymore !</p>
</li>
</ul>
<p>Hence the way most people do mathematics is:</p>
<ul>
<li>
<p>to rely on a minimal set of thoroughly (albeit informally) justified axioms</p>
</li>
<li>
<p>state and prove theorems whenever possible.</p>
</li>
</ul>
<p>The “parti-pris” of LaTTe is to have no fear of axioms, as long as they are <em>mathematical folklore</em>. For example, we have nothing to fear about the Peano axioms of integer arithmetic. And we have no fear of the <em>law (axiom) of the excluded middle</em>, but this is an important topic so let’s open a next section.</p>
<h2><a href="#classical-vs-intuitionistic" id="classical-vs-intuitionistic"></a>Classical vs. Intuitionistic</h2>
<p>Classical reasoning abunds in the mathematics literature.</p>
<p>Some guidelines:</p>
<ul>
<li>
<p>when classical reasoning is the simplest, don’t be shy</p>
</li>
<li>
<p>if a constructive proof is available, and it is not extremely complex if compared to a classical one, then it is to be favored.</p>
</li>
</ul>
<p>The intuitionistic objective of trying to be “constructive only”, and reject the excluded middle, could be pursued in LaTTe (it suffices not to rely on the <a href="null">excluded-middle</a> axiom). But this is not the objective pursued by its authors and the “standard” library.</p>
<p>TODO</p>
<h2><a href="#types-vs-sets" id="types-vs-sets"></a>Types vs. Sets</h2>
<p>The <em>typed vs. untyped</em> debate is a class thema of programming languages. For example, the Clojure is strongly (everything has a type), dynamically (type-checking is performed at runtime) typed. A language such as ML is strongly and statically typed, because type-checking is perfomed at compile-time. Note that finding a truely “untyped” language is not easy (maybe tcl or bash because everything is a string at first ?). There is a related, although distinct, debate between typed and untyped mathematical theories.</p>
<p>For example, the ZF set theory that serve as the “true” foundations for mathematics (this is what’s accepted by many if not all mathematicians) is indeed untyped. A set has no type, it is just a collection of elements with some (axiomatic) constraints (e.g. the foundation axiom ensures that a set cannot be contained in itself).  Types were mostly developed in a mathematical setting for the very problem we are concerned with: the formalization of mathematical reasoning.</p>
<p>We have no strong opinion to defend but it is important to know that LaTTe, being based on a typed lambda-calculus is, of course, a type theory. Hence it is <em>not</em> based on the accepted foundations of mathematics, but relies on an typed alternative. One informal argument that may justify this choice (beyond the beauty of the approach from a computer science point of view) is that in everyday mathematical practice many concepts are informally typed: “consider a set E of integers, etc.”</p>
<p>Note that sets are not completely eliminated from the theory. An expressive notion of typed set can be formulated as a predicate over a type: “the (sub)set of elements of a given type that satisfy a given property” e.g. the subset Nat of the type Int. Many developments of set theory can be restated in this <em>subset</em> setting.</p>
<h2><a href="#dependent-vs-non-dependent-types" id="dependent-vs-non-dependent-types"></a>Dependent vs. non-dependent types</h2>
<p>TODO</p>
</div></div></div></body></html>