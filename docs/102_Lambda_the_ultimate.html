<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Lambda the ultimate</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1  current"><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="latte.core.html"><div class="inner"><span>latte.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#lambda-the-ultimate" id="lambda-the-ultimate"></a>Lambda the ultimate</h1>
<blockquote>
<p>(this document is copyright © 2016 Frédéric Peschanski under the Creative commons CC-BY-SA 4.0)</p>
</blockquote>
<p>Much ink (and bits) have been spilled explaining (and explaining again) the lambda-calculus. And this is what we shall do again here, albeit with quite a focused approach of comparing the lambda-calculus provided by the host language Clojure, to the one implemented by the kernel of LaTTe.</p>
<h2><a href="#lambda-for-computing" id="lambda-for-computing"></a>Lambda for computing</h2>
<p>Most modern programming languages support a form of functional programming in which functions are made first-class. Clojure, being a functional-first programming language, is of course a typical example. The <em>lambda</em> of Clojure is named <code>fn</code>. A primary use of <code>fn</code> is to create (in general short) anonymous functions. Let’s take one of the simplest example: the identity function.</p>
<pre><code class="language-clojure">(fn [x] x)
</code></pre>
<p>In the lambda terminology, this is called an <strong>abstraction</strong>. We say in <code>(fn [x] e)</code> that <code>x</code> is the <em>binding variable</em> and <code>e</code> (an arbitrary expression) is the <em>body</em> of the abstraction. All the <em>free ocurrences</em> of <code>x</code> in <code>e</code> become <em>bound</em> by the abstraction.</p>
<p>To see that the abstraction above represents the identity function, we can apply it to some value:</p>
<pre><code class="language-clojure">((fn [x] x) 42)
;=&gt; 42
</code></pre>
<p>We just encountered two other major ingredients of the lambda-calculus:</p>
<ul>
<li>
<p>an <strong>application</strong> <code>(f e)</code> of a function <code>f</code> to lambda-term <code>e</code></p>
</li>
<li>
<p>a <strong>primitive value</strong> (sometimes also called a constant) <code>42</code></p>
</li>
</ul>
<p>Let’s take a slightly more complex example: the <em>church</em> encoding of pairs in the lambda-calculus (here the one embedded in Clojure).</p>
<pre><code class="language-clojure">(def pair (fn [x] (fn [y] (fn [z] ((z x) y)))))
(def fst (fn [p] (p (fn [x] (fn [y] x)))))
(def snd (fn [p] (p (fn [x] (fn [y] y)))))
</code></pre>
<p>Here are a few example:</p>
<pre><code class="language-clojure">(def p1 ((pair "hello") 42))
(fst p1)
;=&gt; "hello"
(snd p1)
;=&gt; 42
</code></pre>
<p>Note that in Clojure we could define <code>pair</code> more conveniently as <code>(fn [x y] (fn [z] ((z x) y)))</code> such that the construction of a pair would be simpler, e.g. <code>(pair "hello" 42)</code>. However, it is simpler, at least conceptually, to only consider single-argument functions.</p>
<p>The Church thesis is that everything (at least numerically) computable can be expressed with similar encodings in such a “simple” lambda-calculus (or equivalently by Turing machines). While most introductions provide long lists of encodings of things such as booleans, numbers, arithmetic operations, (etc.), we will <em>not</em>. The thing is, such encodings are in general not practical, and most often yield very slow computations.</p>
<p>Before dwelving into the main subject, reasoning with a lambda-calculus, we have to introduce (or remind of) two important features: <em>alpha-conversion</em> and <em>beta-reduction</em>.</p>
<h3><a href="#alpha-conversion" id="alpha-conversion"></a>Alpha-conversion</h3>
<p>First, the syntax of the lambda-calculus relies on a (in fact) non-trivial notion of equality named <em>alpha-equivalence</em>. Under some “non-conflicting” conditions (this is the non-trivial part), renaming a bound variable should not change the syntactic nature of a lambda-term.</p>
<p>For example, both the following terms:</p>
<pre><code class="language-clojure">(fn [x] x)
(fn [y] y)
</code></pre>
<p>represent the identity function. We say the the two terms are <strong>alpha-convertible</strong>.</p>
<p>However, if we consider the pairing function :</p>
<pre><code class="language-clojure">(fn [x] (fn [y] (fn [z] ((z x) y))))
</code></pre>
<p>Then the following is <em>not</em> a correct alpha-conversion:</p>
<pre><code class="language-clojure">(fn [x] (fn [z] (fn [z] ((z x) z))))
</code></pre>
<p>An easy counter-example follows:</p>
<pre><code class="language-clojure">(def pair1 (fn [x] (fn [y] (fn [z] ((z x) y)))))
(def pair2 (fn [x] (fn [z] (fn [z] ((z x) z)))))
 
(snd ((pair1 "hello") 42))
;=&gt; 42

(snd ((pair2 "hello") 42))
;=&gt; #object[user$snd$fn__9927 0x24ee5473 "user$snd$fn__9927@24ee5473"]
</code></pre>
<p>The problem is that we renamed the bound variable <code>y</code> into <code>z</code> but <code>z</code> is already in use. However, the following works:</p>
<pre><code class="language-clojure">(def pair1 (fn [x] (fn [y] (fn [z] ((z x) y)))))
(def pair2 (fn [x] (fn [w] (fn [z] ((z x) w)))))
 
(snd ((pair1 "hello") 42))
;=&gt; 42

(snd ((pair2 "hello") 42))
;=&gt; 42
</code></pre>
<p>The variable name <code>w</code> that was chosen is said <em>fresh</em>, and in this case the renaming is “safe”: the two-terms <code>pair1</code> and <code>pair2</code> are alpha-convertible.</p>
<p>In the practice of programming, we all now the importance of choosing good names for function parameters. This degree of freedom is thanks to alpha-conversion.</p>
<h3><a href="#beta-reduction" id="beta-reduction"></a>Beta-reduction</h3>
<p>An important question is: what is the semantics of the lambda-calculus? The theoretical beauty of the calculus is that it mostly relies on a single (at least apparently) simple rewrite rule: <em>beta-reduction</em>.</p>
<p>Let’s consider again the identity function, called on an argument:</p>
<pre><code class="language-clojure">((fn [x] x) 42)
</code></pre>
<p>While for practical reasons (especially efficiency) things are much more complex, the computation triggered here can be summarized by the following rewrite:</p>
<pre><code class="language-clojure">((fn [x] x) 42) --&gt; 42
</code></pre>
<p>What happened is that the body of the function, the occurrence <code>x</code> was replaced by the value <code>42</code>. This was a beta-reduction. Let’s take the pairing function for a more interesting example:</p>
<pre><code class="language-clojure">;; ((pair "hello") 42) 
(((fn [x] (fn [y] (fn [z] ((z x) y))))
 "hello") 42)
--&gt; ((fn [y] (fn [z] ((z 42) y)) "hello"))
--&gt; (fn [z] ((z 42) "hello"))
</code></pre>
<p>Already two beta-reductions were performed, let’s see what happen when we take the second element of the pair.</p>
<pre><code class="language-clojure">;; (snd ((pair "hello") 42))
((fn [p] (p (fn [x] (fn [y] y))))
 (fn [z] ((z 42) "hello")))
--&gt; ((fn [z] ((z 42) "hello")) ;p
     (fn [x] (fn [y] y)))
--&gt; (((fn [x] (fn [y] y)) 42) "hello")
--&gt; ((fn [y] y) 42)
--&gt; 42
</code></pre>
<p>Note that after 3 beta-reductions we found back our identity function.</p>
<p>In all the situations above, the beta-reduction was trigerred in the context of a sub-expression of the form</p>
<p><code>((fn [x] a) b)</code> where <code>a</code> and <code>b</code> are arbitrary expressions. Such a sub-expression is called a reducible expression or <em>redex</em>.</p>
<p>The beta reduction says that such a redex can be rewritten as expression <code>a</code> in which all the (free) occurrences of <code>x</code> are replaced by <code>b</code>.</p>
<p>This looks like a simple rule but it is not. First, we should remember that modifying a term such as <code>a</code> above should be done with great care in order to avoid name clashes. But most importantly if the easy part is to beta-reduce a redex, the main problem is to find one! For this we need a <em>strategy</em> to find a redex to reduce. In terms of programming, the three most famous strategies are <em>call-by-value</em> (the one implemented by Clojure), <em>call-by-name</em> (that you can find as an option in e.g. Scala) and <em>call-by-need</em> (the one implemented in Haskell). We will not explain these (there are far better sources), but we have to remember two things:</p>
<ul>
<li>
<p>beta-reduction is at the heart of the lambda-calculus semantics</p>
</li>
<li>
<p>a strategy to find the first redex to reduce must be established</p>
</li>
</ul>
<p>And we have now everything at hand to explain the lambda-calculus driving LaTTe.</p>
<h2><a href="#lambda-for-reasoning" id="lambda-for-reasoning"></a>Lambda for reasoning</h2>
<p>The lambda-calculus was for a long time considered as a computational artefact. But Church already felt the interest of the calculus, in its explicitely typed variant, from a logical point of view. This was later more deeply investigated by mathematicians, among them Curry, and then Howard (and many others, of course)… But wait, <em>Curry</em> … <em>Howard</em> … that sounds familiar. What we will investigate now is a deep connection between calculating using the lambda-calculus, as we did in the previous section, and reasoning … also using the lambda-calculus. This is the famous <em>Curry-Howard correspondance</em>.</p>
<h3><a href="#to-type-or-not-to-type-that-is-not-the-question" id="to-type-or-not-to-type-that-is-not-the-question"></a>To type or not to type, that is (not) the question</h3>
<p>The question <em>Why types?</em> is one of the great debates about programming. Clojure programmers obviously made a choice of relying on types at runtime (a.k.a. dynamic typing) instead of at compile-time (a.k.a. static typing). As a consequence, the lambda-calculus embedded in Clojure is itself of an <em>untyped</em> nature.</p>
<p>The expression <code>(fn [x] x)</code> does not contains any explicit (nor implicit) type information. Moreover, the Clojure compiler does not perform any type-checking when encoutering such an expression.</p>
<p>From a logical perspective, the question <em>Why types?</em> is also a debate but as far as the lambda-calculus is concerned, the question is more of the kind: <em>What kind of types?</em>.</p>
<p>There are two “schools” about this:</p>
<ul>
<li>
<p>the <em>typing à la Curry</em> school</p>
</li>
<li>
<p>the <em>typing à la Church</em> school</p>
</li>
</ul>
<p>In the Curry school, the idea is to consider the untyped terms, and try <em>a posteriori</em> to classify them according to their type. There is the underlying idea of <em>type reconstruction</em> behind Curry typing. Curry-typing is a very important principle in statically-typed functional programming languages. For example, if we write the identity function in Ocaml, we get:</p>
<pre><code class="language-ocaml"> fun x -&gt; x ;;
- : 'a -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>This is equivalent to say, for any type <code>'a</code>, then <code>fun x -&gt; x</code>  (the Ocaml version of <code>(fn [x] x)</code>) returns a value of the same type <code>'a</code>. Here, the <code>'a</code> is a <em>type variable</em>, a placeholder for a “real” type, e.g. <code>bool</code>, <code>int</code>, etc.  Curry typing is sometimes called <em>implicit typing</em>.</p>
<p>In the Church school, on the contrary, types must be explicit. Because it uses a very expressive lambda-calculus for which type reconstruction is not decidable,  LaTTe implements an explicitely typed lambda-calculus.</p>
<p>Suppose we have a type <code>A</code>, then the identity function for type <code>A</code> can be written in LaTTe as follows:</p>
<pre><code class="language-clojure">(lambda [x A] x)
</code></pre>
<p>The <code>lambda</code> keyword is of course the <code>fn</code> of LaTTe. The variable <code>x</code> is explicited of having type <code>A</code>.</p>
<p>The type of the previous expression can be written in LaTTe: <code>(==&gt; A A)</code> it is a function that takes an <code>A</code> and yields an <code>A</code>.</p>
<p>We have defined an identity function that is <em>specific</em> to a type <code>A</code> that has not been specified. In clojure the function <code>(fn [x] x)</code> is very generic, it is an identity functions for anything</p>
<pre><code class="language-clojure">((fn [x] x) true) -&gt; true ;; identity for `booleans`
((fn [x] x) 42) -&gt; 42     ;; identity for `integers`
... etc ...
</code></pre>
<p>Is it possible to define such a generic function in LaTTe? The answer is of course yes, and this can be written as follows:</p>
<pre><code class="language-clojure">(lambda [A :type]
  (lambda [x A] x))
</code></pre>
<p>The generic identity function first has a parameter <code>A</code> that is an arbitrary type, and it yields the identity function on <code>A</code>. We give to <code>A</code> the type <code>:type</code> to say that it <em>is</em> an arbitrary type. The constant <code>:type</code> is the <em>type of types</em>.</p>
<p>We can now apply the generic identity in an explicitely-typed context:</p>
<pre><code class="language-clojure">(((lambda [A :type] (lambda [x A] x)) boolean) true)
--&gt; ((lambda [x boolean] x) true)
--&gt; true
</code></pre>
<p>or:</p>
<pre><code class="language-clojure">(((lambda [A :type] (lambda [x A] x)) int) 42)
--&gt; ((lambda [x int] x) 42)
--&gt; 42
</code></pre>
<p>This is clearly a little bit more verbose, so we need a more serious argument in favor of typing. For we should answer the question:</p>
<blockquote>
<p>What is the type of <code>(lambda [A :type] (lambda [x A] x))</code>?</p>
</blockquote>
<p>An adequate answer is obtained thanks to a lambda-calculus named <em>system F</em> (or <em>λ2</em>, or the polymorphic lambda-calculus), and in LaTTe it is as follows:</p>
<pre><code>(forall [A :type]
  (==&gt; A A))
</code></pre>
<p>Note that it is in fact the same type that is reconstructed by Ocaml for the expression <code>fun x -&gt; x</code>.</p>
<p>As a computational statement, the expression above reads:</p>
<blockquote>
<p>for an arbitrary type <code>A</code>, get a function that takes an <code>A</code> and yields an <code>A</code>.</p>
</blockquote>
<p>As a logical statement, the alternative but equivalement reading is:</p>
<blockquote>
<p>for an arbitrary proposition <code>A</code>, it is true that <code>A</code> implies <code>A</code>.</p>
</blockquote>
<p>But wait, this is a simple although fundamental property of propositional logic: <em>reflexivity of implication</em>.</p>
<p>Let’s take a second example, slightly more complex.</p>
<p>Suppose we have a value <code>v</code> of type <code>A</code> and a function <code>f</code> of type <code>(==&gt; A B)</code>. The question is now:</p>
<blockquote>
<p>How to obtain a value of type <code>B</code>?</p>
</blockquote>
<p>From a computational point of view, the answer is obvious: let’s apply <code>f</code> to <code>v</code>, and of course <code>(f v)</code> is of type <code>B</code>.</p>
<p>Now let’s translate this into logical statements… this gives:</p>
<ul>
<li>
<p>suppose we have two propositions <code>A</code> and <code>B</code></p>
</li>
<li>
<p>moreover we have a proof of <code>A</code> named <code>v</code>, and a proof of <code>(==&gt; A B)</code> named <code>f</code></p>
</li>
<li>
<p>a proof of <code>B</code> is <code>(f v)</code>.</p>
</li>
</ul>
<p>What we just did is a <em>demonstration</em> that probably the most important rule of logical deduction - the infamous <em>modus ponens</em> - is a natural interpretation of applying a function to a value in a (typed) lambda-calculus.</p>
<p>Amusingly, such a “proof” is already present in e.g. Ocaml:</p>
<pre><code class="language-ocaml">(fun v -&gt; (fun f -&gt; f v))
- : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &lt;fun&gt;
</code></pre>
<p>For the trained mind, this reads: "from a value of type <code>'a</code> and a function of type <code>'a -&gt; 'b' get a value of type</code>b`. The function works also in Clojure of course:</p>
<pre><code class="language-clojure">(((fn [v] (fn [f] (f v))) 42) even?)
;=&gt; true
</code></pre>
<p>The function <code>even?</code> is (at least philosophically) of type <code>(==&gt; int boolean)</code>, and <code>42</code> is of type <code>int</code> hence we obtain a <code>boolean</code>.</p>
<p>In LaTTe, we can make all this quite explicit:</p>
<pre><code class="language-clojure">(lambda [A :type]
  (lambda [B :type]
    (lambda [v A]
      (lambda [f (==&gt; A B)]
        (f v)))))
</code></pre>
<p>The type of the expression above is as follows:</p>
<pre><code class="language-clojure">(forall [A :type]
  (forall [B :type]
    (forall [v A]
       (forall [f (==&gt; A B)]
          B))))
</code></pre>
<p>This is quite verbose so let’s try to simplify this. We remark that in the type, there is no occurrence of the variables <code>v</code> and <code>F</code> and we have the following law:</p>
<p>If <code>x</code> is a variable, <code>T</code> is a type and <code>U</code> is type in which there is no free occurrence of <code>x</code>, then:</p>
<pre><code class="language-clojure">(forall  [x T] U) ≝ (==&gt; T U)
</code></pre>
<p>(so implication is a special case of universal quantification)</p>
<p>Hence the type of our <em>modus ponens</em> example becomes:</p>
<pre><code class="language-clojure">(forall [A :type]
  (forall [B :type]
    (==&gt; A
         (==&gt; (==&gt; A B)
              B))))
</code></pre>
<p>that can be further simplified (using a simple <em>n-ary</em> version of implication) as follows:</p>
<pre><code class="language-clojure">(forall [A :type]
  (forall [B :type]
    (==&gt; A
         (==&gt; A B)
         B)))
</code></pre>
<p>And the logical reading of this type is eloquent:</p>
<blockquote>
<ul>
<li>suppose <code>A</code> and <code>B</code> two arbitrary propositions</li>
<li>if we know that <code>A</code> is true</li>
<li>and moreover we know that <code>A</code> implies <code>B</code></li>
<li>then <code>B</code> is true.</li>
</ul>
</blockquote>
<p>Logicians like to write this as an <em>inference rule</em>, as follows:</p>
<pre><code>  A     A ==&gt; B
==================
       B
</code></pre>
<p>And in general they call this rule the <em>modus monens</em>.</p>
<p>(but the lambda-calculus expression is more explicit, e.g. about the meaning of the “horizontal bar” and also the quantification of <code>A</code> and <code>B</code>).</p>
<p>This is another extremely important component of (any) logic, and as we see this is completely equivalent to another extremely important component of (any) programming language: <em>function application</em>.</p>
<h3><a href="#the-curry-howard-correspondance" id="the-curry-howard-correspondance"></a>The Curry-Howard correspondance</h3>
<p>What we just experienced in the previous section was discovered (partially) by Haskell Curry and later more concretely explained by William A. Howard (but then refined by many others). It is (hence) named the <em>Curry-Howard correspondance</em> between:</p>
<ul>
<li>
<p>types and terms of a lambda-calculus on the one, computational, side</p>
</li>
<li>
<p>propositions and proofs on the other, logical, side</p>
</li>
</ul>
<p>When we gave a logical reading for lambda-terms in the previous sections, we used:</p>
<ul>
<li>
<p><em>Propositions-as-Types</em> (e.g. suppose an arbitrary proposition <code>A</code>)</p>
</li>
<li>
<p><em>Proofs-as-Terms</em> (e.g. suppose we have a proof <code>v</code> of <code>A</code>)</p>
</li>
</ul>
<p>This is the <em>PaT</em> (or maybe more accurately <em>PaT-PaT</em>) interpretation of a (typed) lambda-calculus, and it is at the heart of LaTTe.</p>
<p>To provide a slightly more advanced example of the interest and use of the <em>PaT</em> interpretation, we will consider once more the pairing function.</p>
<p>In Clojure it was defined as follows:</p>
<pre><code class="language-clojure">(fn [x] (fn [y] (fn [z] ((z x) y))))
</code></pre>
<p>We can give an explicit version in LaTTe, as follows:</p>
<pre><code class="language-clojure">(lambda [A :type]
  (lambda [B :type]
      (lambda [x A]
           (lambda [y B]
        (lambda [C :type]
           (lambda [z (==&gt; A B
                           C)]
                    ((z x) y)))))))
</code></pre>
<p>(wow! that’s verbose…)</p>
<p>The type of this function is more interesting:</p>
<pre><code class="language-clojure">(forall [A :type]
  (forall [B :type]
    (==&gt; A B
        (forall [C :type]
          (==&gt; (==&gt; A B
                  C)
              C)))))
</code></pre>
<p>(wow! that’s also verbose…).</p>
<p>To simplify a little bit matters, let’s now suppose we have the types <code>A</code> and <code>B</code> implicit (we’ll see later how to make them <em>parameters</em>), so we drop the first two <code>lambda</code>’s and get for the pairing function:</p>
<pre><code class="language-clojure">(lambda [x A]
    (lambda [y B]
       (lambda [C :type]
           (lambda [z (==&gt; A B
                           C)]
               ((z x) y)))))))
</code></pre>
<p>The type becomes:</p>
<pre><code class="language-clojure">(==&gt; A B
     (forall [C :type]
        (==&gt; (==&gt; A B
                  C)
             C)))
</code></pre>
<p>That’s a little bit more readable… but we will write this even more concisely by naming <code>(pair A B)</code> the <code>(forall [C :type] ... C)</code> subexpression. We get:</p>
<pre><code class="language-clojure">(==&gt; A B
     (pair A B))
</code></pre>
<p>Now let’s take the function <code>fst</code>:</p>
<pre><code class="language-clojure">(fn [p] (p (fn [x] (fn [y] x))))
</code></pre>
<p>which becomes (still abstracting from <code>A</code> and <code>B</code>):</p>
<pre><code class="language-clojure">(lambda [p (pair A B)]
    (p (lambda [x A]
          (lambda [y B]
              x))))
</code></pre>
<p>The type of the term, once again more interestingly, is:</p>
<pre><code class="language-clojure">(==&gt; (pair A B)
     A)
</code></pre>
<p>So <code>fst</code> is a function that takes a pair of an <code>A</code> and a <code>B</code>, and yield an <code>A</code>, that’s what we expected of course!</p>
<p>And you might then guess what the type of <code>snd</code> is:</p>
<pre><code class="language-clojure">(==&gt; (pair A B)
     B)
</code></pre>
<p>From a <code>(pair A B)</code> it yield a <code>B</code>.</p>
<p>Now let’s apply the <em>PaT</em> interpretation. Because logical names are often far from computational ones, let’s replace <code>(pair A B)</code> by <code>(and-by-all-means A B)</code> (but there is no trick here, it is just an alternative name for the same <em>thing</em>).</p>
<p>The type of the pairing function becomes:</p>
<pre><code class="language-clojure">(==&gt; A B
     (and-by-all-means A B))
</code></pre>
<p>Which, from a logical point of view, reads as follows:</p>
<p>This reads:</p>
<blockquote>
<ul>
<li>If we know that <code>A</code> is true and <code>B</code> is true</li>
<li>Then the conjunction of <code>A</code> and <code>B</code> is true.</li>
</ul>
</blockquote>
<p>In what is called <em>natural deduction</em> in logic this is exactly the definition of the <em>introduction rule for conjunction</em>.</p>
<p>Let’s now take the <code>fst</code> function, whose type becomes:</p>
<pre><code class="language-clojure">(==&gt; (and-by-all-means A B)
     A)
</code></pre>
<p>So:</p>
<blockquote>
<p>If we know that the conjunction of <code>A</code> and <code>B</code> is true Then <code>A</code> “alone” is true</p>
</blockquote>
<p>This is the <em>left elimination rule for conjunction</em> in natural deduction, and of course the right elimation rule of conjunction is demonstrated by the <code>snd</code> function of type:</p>
<pre><code class="language-clojure">(==&gt; (and-by-all-means A B)
     B)
</code></pre>
<p>So what we reconstructed here, using only the lambda-calculus and LaTTe, is the common logical characterization of conjunction in natural deduction with its introduction and elimination rules.</p>
<p>We can go very far based on the Curry-Horward correspondance, and essentially all of logic and (arguably) mathematics can be built using a similar process.</p>
<p>At least it is hoped that the previous examples provide a good illustration of the deep connection existing between computation (types, expressions, function application) and reasoning (propositions, proofs, deduction) in a typed lambda-calculus.</p>
<p>It is now time to be a little bit more explicit about the particular calculus implemented in LaTTe.</p>
<h2><a href="#the-calculus-of-constructions-aka-λc" id="the-calculus-of-constructions-aka-λc"></a>The Calculus of Constructions (a.k.a. λC)</h2>
<p>At the lowest-level of the LaTTe kernel sits a relatively simple although very expressive lambda-calculus. It is an implementation of the <em>Calculus of Constructions</em> (first defined by <em>Thierry Coquand</em>) and often called <em>λC</em> nowadays.</p>
<p>Remark: it is not impossible, but difficult, to write low-level lambda terms in LaTTe. This is both to be as faithful as possible to the theory and also to avoid working with low-level terms directly (they are somewhat unreadable even for the trained mind). Thanksfully, LaTTe also provides a <em>parser</em> for higher-level terms, the ones manipulated by the users.</p>
<p>Some lambda-calculi are untyped, other ones make a clear distinction between terms on the one side, and types on the other side. This is <em>not</em> the case with λC, although some terms are types and others are not (of course !). We will see how to distinguish them.</p>
<p>A (low-level) lambda-term in LaTTe is either:</p>
<ul>
<li>the constant: <code>✳</code> named <strong>type</strong></li>
</ul>
<p>This corresponds to the <em>type of types</em>. A lambda-term is said a <em>proper type</em> if its type is <code>□</code>. In the concrete syntax <code>□</code> is more conveniently written <code>:type</code>.</p>
<ul>
<li>the constant  <code>□</code> named <strong>kind</strong></li>
</ul>
<p>This is to give a type to <code>□</code> (<code>:type</code>). The type of <code>□</code> is <code>□</code> (or <code>:kind</code> in the concrete syntax) and <code>□</code> <em>has no type</em>. For the sake of logical consistency, it is important that the type hierarchy stops somewhere, and it stops at the kind level (it is possible to introduce universes so that the hierarchy doesn’t stop while preserving consistency, however for the sake of minimalism LaTTe doesn’t need nor use universes… It is then said <em>impredicative</em>, which is nothing similar to a disease).</p>
<ul>
<li>a  <strong>lambda-abstraction</strong> <code>(λ [x T] e)</code> with <code>x</code> the name of the <strong>binding variable</strong>, <code>T</code> a term corresponding to the type of <code>x</code> and <code>e</code> a lambda-term called the <strong>body</strong> of the abstraction</li>
</ul>
<p>This is as we largely discussed the (single-argument) function constructor. In the concrete syntax, the most common notations are as follows:</p>
<pre><code class="language-clojure">(lambda [x T] e) ≡ (λ [x T] e)

(lambda [x1 x2 ... xN T] e)
≡ (λ [x1 T] (λ [x2 T] ... (λ [xN T] e) ... ))
</code></pre>
<ul>
<li>a <strong>product-abstraction</strong> (a.k.a. <em>Π-type</em>) <code>(Π [x T] e)</code> (with <code>x</code>, <code>T</code>, <code>e</code> as in the lambda case)</li>
</ul>
<p>The <em>Π-types</em> are probably the most distinguishing feature of type theories such as <em>λC</em>. These simply are the <em>types</em> of the lambda-abstractions.</p>
<p>If a lambda-term <code>e</code> has type <code>U</code> in the context that <code>x</code> is of type <code>T</code>, then the type of <code>(λ [x T] e)</code> is <code>(Π [x T] U)</code>.</p>
<p>In the concrete syntax, the most common used notations are as follows:</p>
<pre><code class="language-clojure">(forall [x T] U) ≡ (Π [x T] U)

(forall [x1 x2 ... xN T] U)
≡ (Π [x1 T] (Π [x2 T] ... (Π [xN T] e) ... ))
</code></pre>
<p>Yes, of course! This is the <em>universal quantifier</em> of the logic.</p>
<p>Moreover, if in <code>(Π [x T] U)</code> the variable <code>x</code> does not occur freely in <code>U</code>, then an equivalent notation is <code>(==&gt; T U)</code>.  This is thus not only universal quantification but <em>also</em> (as a specific case) the type of functions from <code>T</code> to <code>U</code> <em>and</em> the <em>implication</em> that from <code>T</code> we can get <code>U</code>.</p>
<p>A syntactic shortcut allows to chain the implications:</p>
<pre><code class="language-clojure">(==&gt; T1 T2 T3) ≡ (==&gt; T1
                      (==&gt; T2 T3))

(==&gt; T1 T2 T3 T4) ≡ (==&gt; T1
                         (==&gt; T2
                              (==&gt; T4 T4)))

;; etc...
</code></pre>
<ul>
<li>an occurrence of a <strong>variable</strong> <code>x</code>, <code>y</code>, <code>A</code>, <code>B</code>, etc.</li>
</ul>
<p>The variables are for example introduced by the abstractions (they can also be introduced by parameteric definitions, as discussed later on). The type of each variable is to be found in what is called the <em>context</em> or <em>typing context</em>.</p>
<ul>
<li>an <strong>application</strong> <code>[f e]</code> with <code>f</code> and <code>e</code> lambda-terms, informally <code>f</code> a function and <code>e</code> its argument</li>
</ul>
<p>If <code>f</code> is is type <code>(Π [x T] U)</code> and <code>e</code> is of type <code>T</code> then <code>[f e]</code> is of type <code>U</code> and realizes through beta-reduction the application of the function <code>f</code> on argument <code>e</code>.</p>
<p><em>Remark</em>: the non-standard use of square brackets is to distinguish at the syntax level the applications for the refence terms below… In the concrete syntax the parentheses may be used, the Lisp way as: <code>(f e)</code>. Since we know that all abstrations have a single argument, the following syntactic shortcuts are quite useful:</p>
<pre><code class="language-clojure">(e1 e2) ≡ [e1 e2]  ;; if e1 is not a defined term
(e1 e2 e3) ≡ [[e1 e2] e3]
(e1 e2 e3 e4) ≡ [[[e1 e2] e3] e4]
;; etc.
</code></pre>
<ul>
<li>a <strong>reference</strong> <code>(r e1 ... eN)</code> with <code>r</code> the name of a <strong>defined term</strong> and <code>e1</code> … <code>eN</code> lambda-rterms intended as arguments.</li>
</ul>
<p>The references correpond to an extension of the calculus of constructions by <em>definitional features</em>, and it gives a calculus named <em>λD</em>. The idea is to have a term that references either a definition, an axiom or a theorem.</p>
<p>If a term references a definition, then the definition is simply unfolded as in calling a function.</p>
<p>For example, the definition of conjunction in LaTTe (cf. <a href="null">latte.prop/and</a>) is as follows:</p>
<pre><code class="language-clojure">(definition and
  "logical conjunction."
  [[A :type] [B :type]]
  (forall [C :type]
    (==&gt; (==&gt; A B C)
         C)))
</code></pre>
<p>So a term such as <code>(and (&gt; x 3) (&lt;= x 8))</code> is equivalent to:</p>
<pre><code class="language-clojure">(forall [C :type]
  (==&gt; (==&gt; (&gt; x 3) (&lt;= x 8) C)
       C))
</code></pre>
<p>The type of the reference is the same as the type of the unfolded term.</p>
<p>In the case of an axiom, the reference is considered similar to a constant, except with the parameters replaced by the arguments. The most famous (and sometimes controversed) axiom is probably the law of the <em>excluded middle</em> of classical logic. It is defined as follows in LaTTe (in <a href="null">latte.classic</a>):</p>
<pre><code class="language-clojure">(defaxiom excluded-middle-ax
  "..."
  [[A :type]]
  (or A (not A)))
</code></pre>
<p>So for example a reference <code>(or (&gt; x 3) (not (&gt; x 3)))</code> can be considered inhabited (hence true), even though there is no underlying lambda-calculus term.</p>
<p>In the case of a theorem, then it is a little bit the same except that if a proof term is available then we could, in theory, consider the theorem as a definition and replace the reference term by the proof.</p>
<p>For exemple, based on the following theorem and proof (from <a href="null">latte.prop</a>):</p>
<pre><code class="language-clojure">(defthm impl-ignore
  "A variant of reflexivity."
  [[A :type] [B :type]]
  (==&gt; A B A))

(proof impl-ignore
    :term (lambda [x A] (lambda [y B] x)))
</code></pre>
<p>The term <code>(impl-ignore (&gt; a 2) (&lt;= b 10))</code> could be replaced by the following term:</p>
<pre><code class="language-clojure">(lambda [x (&gt; a 2)]
  (lambda [y (&lt;= b 10)]
     x))
</code></pre>
<p>However, in practice, the references for theorems are not unfolded because it is useless since we already know the type of the proof term. Otherwise, the proofs that reference many theorems would yield very large proof terms.</p>
<h3><a href="#fundamental-properties" id="fundamental-properties"></a>Fundamental properties</h3>
<p>We now discuss the fundamental properties of the calculus of constructions with definitions that is implemented in LaTTe. These properties are important requirements when considering the formalization of logic.</p>
<p>First, let’s remind that the syntactic equality of lambda-terms is governed by <em>alpha-conversion</em>, and the semantics are driven by <em>beta-reduction</em>.</p>
<p>The first important property of the calculus is what is called <strong>strong normalization</strong>.</p>
<p>TODO :</p>
<ul>
<li>
<p>a term is said in <em>normal form</em> iff there is not any redex.</p>
</li>
<li>
<p>weak normalization means that if from a given term two normal forms are reached, then these must be alpha-convertible. Show two distinct strategies for <code>(snd ((pair "hello") 42))</code>.</p>
</li>
<li>
<p>but in e.g. the untyped lambda-calculus, there are terms with no normal forms.</p>
</li>
<li>
<p>and with some strategies, some normal forms cannot be reached</p>
</li>
<li>
<p>strong normalization is weak normalization + all terms have a normal form</p>
</li>
</ul>
<p>The second important property is the <strong>decidability and uniqueness of typing</strong>.</p>
<p>In LaTTe if a term has a type, then it is unique (up-to beta-equivalence). Moreover, given a term we can compute its type (if it has one). This is a very powerful feature, which is only rarely present in proof assistants based on type theory.</p>
</div></div></div></body></html>