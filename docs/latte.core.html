<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="latte.core.html"><div class="inner"><span>latte.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte.core.html#var-*proof-certification-enabled*"><div class="inner"><span>*proof-certification-enabled*</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-assume"><div class="inner"><span>assume</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defaxiom"><div class="inner"><span>defaxiom</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defimplicit"><div class="inner"><span>defimplicit</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defimplicit*"><div class="inner"><span>defimplicit*</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-definition"><div class="inner"><span>definition</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-deflemma"><div class="inner"><span>deflemma</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defnotation"><div class="inner"><span>defnotation</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defthm"><div class="inner"><span>defthm</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-example"><div class="inner"><span>example</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-forall"><div class="inner"><span>forall</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-have"><div class="inner"><span>have</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-lambda"><div class="inner"><span>lambda</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-pose"><div class="inner"><span>pose</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-proof"><div class="inner"><span>proof</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-qed"><div class="inner"><span>qed</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-search-theorem"><div class="inner"><span>search-theorem</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-term"><div class="inner"><span>term</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-term-eq.3F"><div class="inner"><span>term-eq?</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-the-type-of"><div class="inner"><span>the-type-of</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-try-example"><div class="inner"><span>try-example</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-try-proof"><div class="inner"><span>try-proof</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-type-check.3F"><div class="inner"><span>type-check?</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-type-of"><div class="inner"><span>type-of</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte.core</h1><div class="doc"><div class="markdown"><p>This namespace provides the top-level forms of the LaTTe framework.</p>
</div></div><div class="public anchor" id="var-*proof-certification-enabled*"><h3>*proof-certification-enabled*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-assume"><h3>assume</h3><h4 class="type">macro</h4><div class="usage"><code>(assume params &amp; body)</code></div><div class="doc"><div class="markdown"><p>An assume step of the form <code>(assume [x1 T1 x2 T2 ...] &lt;body&gt;)</code>.</p>
</div></div></div><div class="public anchor" id="var-defaxiom"><h3>defaxiom</h3><h4 class="type">macro</h4><div class="usage"><code>(defaxiom &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of an axiom of the form:</p>
<pre><code>  (defaxiom &lt;name&gt;
    "&lt;docstring&gt;"
    [[x1 T1] ... [xN TN]] ;; &lt;params&gt;
    &lt;body&gt;)
</code></pre>
<p>with the specified <code>name</code> (first argument) an optional <code>docstring</code> (second argument), a vector <code>params</code> of parameters and the axiom <code>body</code>, the axiom statement as a lambda-term (last argument). Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its type.</p>
<p>An axiom is accepted without a proof, and should thus be used with extra care. The LaTTe rule of thumb is that theorems should be favored, but axioms are sometimes required (e.g. the law of the excluded middle) or more “reasonable” because of the proof length or complexity. In all cases the introduction of an axiom must be justified with strong (albeit informal) arguments.</p>
</div></div></div><div class="public anchor" id="var-defimplicit"><h3>defimplicit</h3><h4 class="type">macro</h4><div class="usage"><code>(defimplicit &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-defimplicit*"><h3>defimplicit*</h3><h4 class="type">macro</h4><div class="usage"><code>(defimplicit* &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-definition"><h3>definition</h3><h4 class="type">macro</h4><div class="usage"><code>(definition &amp; args)</code></div><div class="doc"><div class="markdown"><p>Defines a mathematical term with the following structure:</p>
<pre><code>(definition &lt;name&gt;
  "&lt;docstring&gt;"
  [[x1 T1] ... [xN TN]] ;; &lt;params&gt;
  &lt;body&gt;)
</code></pre>
<p>composed of a <code>name</code>, and optional (but highly recommended) <code>docstring</code>, a vector <code>params</code> of parameters (typed variables) and <code>body</code> (a lambda-term) as definitional content.</p>
<p>An <code>ex-info</code> exception is thrown if the term cannot be defined.</p>
<p>Note that a definition is a <code>def</code> in the Clojure sense, the term is defined in the namespace where the <code>definition</code> form is invoked.</p>
</div></div></div><div class="public anchor" id="var-deflemma"><h3>deflemma</h3><h4 class="type">macro</h4><div class="usage"><code>(deflemma &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a lemma, i.e. an auxiliary theorem. In LaTTe a lemma is private. To export a theorem the <a href="latte.core.html#var-defthm">defthm</a> form must be used instead. Otherwise the two forms are the same.</p>
</div></div></div><div class="public anchor" id="var-defnotation"><h3>defnotation</h3><h4 class="type">macro</h4><div class="usage"><code>(defnotation &amp; args)</code></div><div class="doc"><div class="markdown"><p>Defines a new notation, which is a function called at parsing time. The result must be pair <code>[status u]</code> with <code>status</code> either <code>:ok</code> (parsing successful) with <code>u</code> the term generated by the notation, or <code>:ko</code> (parsing failed) and <code>u</code> is the error, a map with at least a key <code>:msg</code> explaining the failure.</p>
<p>Be careful that the parser will be called recursively on the generated term, hence recursive definitions must be handled with great care.</p>
</div></div></div><div class="public anchor" id="var-defthm"><h3>defthm</h3><h4 class="type">macro</h4><div class="usage"><code>(defthm &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a theorem of the following form:</p>
<pre><code> (defthm &lt;name&gt;
   "&lt;docstring&gt;"
   [[x1 T1] ... [xN TN]] ;; &lt;params&gt;
   &lt;body&gt;)
</code></pre>
<p>with the specified <code>name</code> (first argument) an optional <code>docstring</code> (second argument), a vector <code>params</code> of parameters and the theorem proposition as <code>body</code> (last argument). Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its type.</p>
<p>A theorem declared must later on be demonstrated using the <a href="latte.core.html#var-proof">proof</a> form. As a side effect, the statement of the theorem is recorded in the current namespace (i.e. it is a Clojure <code>def</code>).</p>
</div></div></div><div class="public anchor" id="var-example"><h3>example</h3><h4 class="type">macro</h4><div class="usage"><code>(example &amp; args)</code></div><div class="doc"><div class="markdown"><p>An example of the form <code>(example T &lt;steps&gt;)</code> is the statement of a proposition, as a type <code>T</code>, as well as a proof.</p>
</div></div></div><div class="public anchor" id="var-forall"><h3>forall</h3><div class="usage"><code>(forall params body)</code></div><div class="doc"><div class="markdown"><p>The universal quantifier <code>(forall [x A] t)</code> is ∀x:A.t (or Πx:A.t in type theory).</p>
<p>As a syntactic sugar an expression of form <code>(forall [x y z A] t)</code> translates to <code>(forall [x A] (forall [y A] (forall [z A] t)))</code></p>
</div></div></div><div class="public anchor" id="var-have"><h3>have</h3><h4 class="type">macro</h4><div class="usage"><code>(have have-name have-type by-kw have-term)</code></div><div class="doc"><div class="markdown"><p>A have step of the form <code>(have &lt;x&gt; T :by e)</code> checks that the term <code>e</code> is of type <code>T</code>. If it is the case, then the fact is recorded as a local definition named <code>&lt;x&gt;</code>. Otherwise an error is signaled. The type <code>T</code> can be replaced by <code>_</code> in which case is is inferred rather than checked. The name <code>&lt;x&gt;</code> can be replaced by <code>_</code> in which case no definition is recorded.</p>
</div></div></div><div class="public anchor" id="var-lambda"><h3>lambda</h3><div class="usage"><code>(lambda params body)</code></div><div class="doc"><div class="markdown"><p>The abstraction <code>(lambda [x A] t)</code> is λx:A.t.</p>
<p>As a syntactic sugar an expression of form <code>(lambda [x y z A] t)</code> translates to <code>(lambda [x A] (lambda [y A] (lambda [z A] t)))</code></p>
</div></div></div><div class="public anchor" id="var-pose"><h3>pose</h3><h4 class="type">macro</h4><div class="usage"><code>(pose pose-name pose-kw pose-term)</code></div><div class="doc"><div class="markdown"><p>A local definition <code>(pose P := e)</code> allows a proof to refer to term <code>e</code> under the name <code>P</code> in a proof. This is equivalent to <code>(have P _ :by e)</code> (with the type of <code>e</code> inferred).</p>
</div></div></div><div class="public anchor" id="var-proof"><h3>proof</h3><div class="usage"><code>(proof thm-name &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Provides a proof of theorem named <code>thm-name</code> using the given proof <code>steps</code>.</p>
</div></div></div><div class="public anchor" id="var-qed"><h3>qed</h3><h4 class="type">macro</h4><div class="usage"><code>(qed qed-term)</code></div><div class="doc"><div class="markdown"><p>A Qed step of the form <code>(qed e)</code> checks that the term <code>e</code> allows to finish a proof in the current context. An error is signaled if the proof cannot be concluded.</p>
</div></div></div><div class="public anchor" id="var-search-theorem"><h3>search-theorem</h3><div class="usage"><code>(search-theorem patt)</code><code>(search-theorem where patt)</code></div><div class="doc"><div class="markdown"><p>Search a theorem using pattern <code>patt</code>. A pattern (generally quoted) is either: - any clojure value, that has to be matched exactly, with the exception of a symbol starting with a question mark (denoting a variable) - a simple variable <code>?X</code> that can match anything - a list/sequence of patterns <code>(patt1 patt2 ...)</code> - a zero-or-many variable <code>?Y*</code> that matches zero or more times greedily - a one-or-many variable <code>?Z+</code> that matches at least once greedily - an optional variable <code>?V?</code> that matches at most once The optional argument <code>where</code> is the name (symbol) of a namespace where the search must be applied (by default, use all registered namespaces)</p>
<p>The special variables <code>?_</code>, <code>?_*</code>,  <code>?_+</code> and <code>?_?</code> produce no binding when matched.</p>
<p>The result is a vector of matches, each match being a pair <code>[theorem-var match-env]</code> with <code>theorem-var</code> the reference to the theorem as a clojure var, and <code>match-env</code> the variable bindings corresponding to the match.</p>
</div></div></div><div class="public anchor" id="var-term"><h3>term</h3><h4 class="type">macro</h4><div class="usage"><code>(term &amp; args)</code></div><div class="doc"><div class="markdown"><p>Parse a LaTTe term at the top-level. A context can be provided in the form of a serie of <code>[var type]</code> pairs before the actual term.</p>
</div></div></div><div class="public anchor" id="var-term-eq.3F"><h3>term-eq?</h3><h4 class="type">macro</h4><div class="usage"><code>(term-eq? &amp; args)</code></div><div class="doc"><div class="markdown"><p>Checks if two terms <code>t</code> and <code>u</code> are equal in the sense of having the “same” normal form (up-to alpha-conversion, the safe renaming of bound variables.</p>
<p>A context can be provided in the form of a serie of <code>[var type]</code> pairs before the actual term.</p>
</div></div></div><div class="public anchor" id="var-the-type-of"><h3>the-type-of</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Replaces the provided term by its inferred type.</p>
</div></div></div><div class="public anchor" id="var-try-example"><h3>try-example</h3><h4 class="type">macro</h4><div class="usage"><code>(try-example &amp; args)</code></div><div class="doc"><div class="markdown"><p>This is the same as <a href="latte.core.html#var-example">example</a> but without throwing exceptions.</p>
</div></div></div><div class="public anchor" id="var-try-proof"><h3>try-proof</h3><div class="usage"><code>(try-proof thm-name &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Provides a proof of theorem named <code>thm-name</code> using the given proof <code>steps</code>. This version only checks if the proof is correct or not, use the <a href="latte.core.html#var-proof">proof</a> function for actually registering the proof.</p>
</div></div></div><div class="public anchor" id="var-type-check.3F"><h3>type-check?</h3><h4 class="type">macro</h4><div class="usage"><code>(type-check? &amp; args)</code></div><div class="doc"><div class="markdown"><p>Check if a term <code>t</code> in of the specified type <code>ty</code>. A context can be specified as with <a href="latte.core.html#var-type-of">type-of</a>.</p>
</div></div></div><div class="public anchor" id="var-type-of"><h3>type-of</h3><h4 class="type">macro</h4><div class="usage"><code>(type-of &amp; args)</code></div><div class="doc"><div class="markdown"><p>Give the type of a term <code>t</code> in a context at the top-level. To only parse the term use <a href="latte.core.html#var-term">term</a>.</p>
</div></div></div></div></body></html>