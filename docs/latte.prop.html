<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte.prop documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">0.102.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte</span></div></div></li><li class="depth-2 branch"><a href="latte.classic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classic</span></div></a></li><li class="depth-2 branch"><a href="latte.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte.equal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equal</span></div></a></li><li class="depth-2 branch"><a href="latte.fun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fun</span></div></a></li><li class="depth-2 branch current"><a href="latte.prop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prop</span></div></a></li><li class="depth-2"><a href="latte.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte.prop.html#var-.3C.3D.3E"><div class="inner"><span>&lt;=&gt;</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-absurd"><div class="inner"><span>absurd</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-absurd-intro"><div class="inner"><span>absurd-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-left"><div class="inner"><span>and-elim-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-left-thm"><div class="inner"><span>and-elim-left-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-right"><div class="inner"><span>and-elim-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-elim-right-thm"><div class="inner"><span>and-elim-right-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-intro"><div class="inner"><span>and-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-intro-thm"><div class="inner"><span>and-intro-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-sym"><div class="inner"><span>and-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-sym-thm"><div class="inner"><span>and-sym-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-and-unparser"><div class="inner"><span>and-unparser</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-decompose-and-type"><div class="inner"><span>decompose-and-type</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-decompose-iff-type"><div class="inner"><span>decompose-iff-type</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-decompose-impl-type"><div class="inner"><span>decompose-impl-type</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-decompose-or-type"><div class="inner"><span>decompose-or-type</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-ex-falso"><div class="inner"><span>ex-falso</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-if"><div class="inner"><span>iff-elim-if</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-if-thm"><div class="inner"><span>iff-elim-if-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-only-if"><div class="inner"><span>iff-elim-only-if</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-elim-only-if-thm"><div class="inner"><span>iff-elim-only-if-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-intro"><div class="inner"><span>iff-intro</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-intro-thm"><div class="inner"><span>iff-intro-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-refl"><div class="inner"><span>iff-refl</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-sym"><div class="inner"><span>iff-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-sym-thm"><div class="inner"><span>iff-sym-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-trans"><div class="inner"><span>iff-trans</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-iff-trans-thm"><div class="inner"><span>iff-trans-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-ignore"><div class="inner"><span>impl-ignore</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-not-not"><div class="inner"><span>impl-not-not</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-refl"><div class="inner"><span>impl-refl</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-trans"><div class="inner"><span>impl-trans</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-impl-trans-thm"><div class="inner"><span>impl-trans-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-not"><div class="inner"><span>not</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-assoc"><div class="inner"><span>or-assoc</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-assoc-conv-thm"><div class="inner"><span>or-assoc-conv-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-assoc-thm"><div class="inner"><span>or-assoc-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-elim"><div class="inner"><span>or-elim</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-elim-thm"><div class="inner"><span>or-elim-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-left"><div class="inner"><span>or-intro-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-left-thm"><div class="inner"><span>or-intro-left-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-right"><div class="inner"><span>or-intro-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-intro-right-thm"><div class="inner"><span>or-intro-right-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-not-elim-left"><div class="inner"><span>or-not-elim-left</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-not-elim-right"><div class="inner"><span>or-not-elim-right</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-not-impl-elim"><div class="inner"><span>or-not-impl-elim</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-sym"><div class="inner"><span>or-sym</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-sym-thm"><div class="inner"><span>or-sym-thm</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-or-unparser"><div class="inner"><span>or-unparser</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-truth"><div class="inner"><span>truth</span></div></a></li><li class="depth-1"><a href="latte.prop.html#var-truth-is-true"><div class="inner"><span>truth-is-true</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte.prop</h1><div class="doc"><div class="markdown"><p>Basic definitions and theorems for (intuitionistic) propositional logic. Most natural deduction rules are provided as theorems in this namespace.</p></div></div><div class="public anchor" id="var-.3C.3D.3E"><h3>&lt;=&gt;</h3><div class="usage"><code>(&lt;=&gt; [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(and (==&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Definition</strong>: Logical equivalence or ‘if and only if’.</p></div></div></div><div class="public anchor" id="var-absurd"><h3>absurd</h3><div class="usage"><code>(absurd)</code></div><div class="doc"><div class="markdown"><pre><code>(forall [α :type] α)
</code></pre>
<p><strong>Definition</strong>: Absurdity.</p></div></div></div><div class="public anchor" id="var-absurd-intro"><h3>absurd-intro</h3><div class="usage"><code>(absurd-intro [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not A) absurd)
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for absurdity.</p></div></div></div><div class="public anchor" id="var-and"><h3>and</h3><div class="usage"><code>(and [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A B C) C))
</code></pre>
<p><strong>Definition</strong>: logical conjunction.</p></div></div></div><div class="public anchor" id="var-and-elim-left"><h3>and-elim-left</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-elim-left and-term)</code></p>
<p>An implicit elimination rule that takes a proof of type <code>(and A B)</code> and yields a proof of <code>A</code>.</p>
<p>This is an implicit version of <a href="latte.prop.html#var-and-elim-left-thm">and-elim-left-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-elim-left-thm"><h3>and-elim-left-thm</h3><div class="usage"><code>(and-elim-left-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) A)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical conjunction.  This one only keeps the left-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-elim-right"><h3>and-elim-right</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-elim-right and-term)</code></p>
<p>An implicit elimination rule that takes a proof <code>and-term</code> of type <code>(and A B)</code> and yields a proof of <code>B</code>.</p>
<p>This is an implicit version of <a href="latte.prop.html#var-and-elim-right-thm">and-elim-right-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-elim-right-thm"><h3>and-elim-right-thm</h3><div class="usage"><code>(and-elim-right-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) B)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical conjunction.  This one only keeps the right-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-intro"><h3>and-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-intro a b)</code></p>
<p>An introduction rule that takes a proof <code>a</code> of type <code>A</code>, a proof <code>b</code> of type <code>B</code> and yields a proof of type <code>(and A B)</code>.</p>
<p>This is an implicit version of <a href="latte.prop.html#var-and-intro-thm">and-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-intro-thm"><h3>and-intro-thm</h3><div class="usage"><code>(and-intro-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B (and A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical conjunction.</p></div></div></div><div class="public anchor" id="var-and-sym"><h3>and-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-sym and-term)</code></p>
<p>Symmetry of conjunction, an implicit version of <a href="null">and-sym-</a>.</p></div></div></div><div class="public anchor" id="var-and-sym-thm"><h3>and-sym-thm</h3><div class="usage"><code>(and-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) (and B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of conjunction.</p></div></div></div><div class="public anchor" id="var-and-unparser"><h3>and-unparser</h3><div class="usage"><code>(and-unparser term)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-and-type"><h3>decompose-and-type</h3><div class="usage"><code>(decompose-and-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-iff-type"><h3>decompose-iff-type</h3><div class="usage"><code>(decompose-iff-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-impl-type"><h3>decompose-impl-type</h3><div class="usage"><code>(decompose-impl-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-or-type"><h3>decompose-or-type</h3><div class="usage"><code>(decompose-or-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ex-falso"><h3>ex-falso</h3><div class="usage"><code>(ex-falso [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; absurd A)
</code></pre>
<p><strong>Theorem</strong>: Ex falso sequitur quodlibet  (proof by contradiction, elimination for absurdity).</p></div></div></div><div class="public anchor" id="var-iff-elim-if"><h3>iff-elim-if</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-elim-if iff-term)</code></p>
<p>Left (if) elimination for <code>&lt;=&gt;</code>, an implicit version of <a href="latte.prop.html#var-iff-elim-if-thm">iff-elim-if-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-elim-if-thm"><h3>iff-elim-if-thm</h3><div class="usage"><code>(iff-elim-if-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; A B))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical equivalence.  This one only keeps the if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-elim-only-if"><h3>iff-elim-only-if</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-elim-only-if iff-term)</code></p>
<p>Right (only if) elimination for <code>&lt;=&gt;</code>, an implicit version of <a href="latte.prop.html#var-iff-elim-only-if-thm">iff-elim-only-if-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-elim-only-if-thm"><h3>iff-elim-only-if-thm</h3><div class="usage"><code>(iff-elim-only-if-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical equivalence.  This one only keeps the only-if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-intro"><h3>iff-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-intro ab ba)</code></p>
<p>Introduction rule for logical equivalence, an implicit version of <a href="latte.prop.html#var-iff-intro-thm">iff-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-intro-thm"><h3>iff-intro-thm</h3><div class="usage"><code>(iff-intro-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B A) (&lt;=&gt; A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-refl"><h3>iff-refl</h3><div class="usage"><code>(iff-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; A A)
</code></pre>
<p><strong>Theorem</strong>: Reflexivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-sym"><h3>iff-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-sym iff-term)</code></p>
<p>Symmetry of <code>&lt;=&gt;</code>, an implicit version of <a href="latte.prop.html#var-iff-sym-thm">iff-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-sym-thm"><h3>iff-sym-thm</h3><div class="usage"><code>(iff-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-trans"><h3>iff-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-trans iff-term1 iff-term2)</code></p>
<p>Transitivity of <code>&lt;=&gt;</code>, an implicit version of <a href="latte.prop.html#var-iff-trans-thm">iff-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-trans-thm"><h3>iff-trans-thm</h3><div class="usage"><code>(iff-trans-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B C) (&lt;=&gt; A C))
</code></pre>
<p><strong>Theorem</strong>: Transitivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-impl-ignore"><h3>impl-ignore</h3><div class="usage"><code>(impl-ignore [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B A)
</code></pre>
<p><strong>Theorem</strong>: A variant of reflexivity.</p></div></div></div><div class="public anchor" id="var-impl-not-not"><h3>impl-not-not</h3><div class="usage"><code>(impl-not-not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not (not A)))
</code></pre>
<p><strong>Theorem</strong>: The if half of double negation.</p>
<p>This can be seen as an introduction rule for ¬¬ (not-not) propositions. Note that double-negation is a law of classical (non-intuitionistic) logic.</p></div></div></div><div class="public anchor" id="var-impl-refl"><h3>impl-refl</h3><div class="usage"><code>(impl-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A A)
</code></pre>
<p><strong>Theorem</strong>: Implication is reflexive.</p></div></div></div><div class="public anchor" id="var-impl-trans"><h3>impl-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(impl-trans impl1 impl2)</code></p></div></div></div><div class="public anchor" id="var-impl-trans-thm"><h3>impl-trans-thm</h3><div class="usage"><code>(impl-trans-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B C) (==&gt; A C))
</code></pre>
<p><strong>Theorem</strong>: Implication is transitive.</p></div></div></div><div class="public anchor" id="var-not"><h3>not</h3><div class="usage"><code>(not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A absurd)
</code></pre>
<p><strong>Definition</strong>: Logical negation.</p></div></div></div><div class="public anchor" id="var-or"><h3>or</h3><div class="usage"><code>(or [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C))
</code></pre>
<p><strong>Definition</strong>: logical disjunction.</p></div></div></div><div class="public anchor" id="var-or-assoc"><h3>or-assoc</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-assoc or-term)</code></p>
<p>Associativity of disjunction, an implicit that subsumes both <a href="latte.prop.html#var-or-assoc-thm">or-assoc-thm</a> and <a href="latte.prop.html#var-or-assoc-conv-thm">or-assoc-conv-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-assoc-conv-thm"><h3>or-assoc-conv-thm</h3><div class="usage"><code>(or-assoc-conv-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A (or B C)) (or (or A B) C))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-or-assoc-thm"><h3>or-assoc-thm</h3><div class="usage"><code>(or-assoc-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or (or A B) C) (or A (or B C)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-or-elim"><h3>or-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-elim or-term prop left-proof right-proof)</code></p>
<p>An elimination rule that takes a proof  <code>or-term</code> of type <code>(or A B)</code>, a proposition <code>prop</code>, a proof <code>left-proof</code> of type <code>(==&gt; A prop)</code>, a proof <code>right-proof</code> of type <code>(==&gt; B prop)</code>, and thus concludes that <code>prop</code> holds by <code>[[or-elim-thm]]</code>.</p>
<p>This is (for now) the easiest rule to use for proof-by-cases.</p></div></div></div><div class="public anchor" id="var-or-elim-thm"><h3>or-elim-thm</h3><div class="usage"><code>(or-elim-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C)))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical disjunction.</p>
<p>Remark: this rule, reflecting the definition of <a href="latte.prop.html#var-or">or</a>, provides a  constructive way to eliminate disjunctions. A simpler elimination process is offered if one  of the two disjuncts does not hold: cf. <a href="latte.prop.html#var-or-not-elim-left">or-not-elim-left</a> and <a href="latte.prop.html#var-or-not-elim-right">or-not-elim-right</a>.</p></div></div></div><div class="public anchor" id="var-or-intro-left"><h3>or-intro-left</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-intro-left left-term right-type)</code></p>
<p>Left introduction for disjunction, an implicit version of <a href="latte.prop.html#var-or-intro-left-thm">or-intro-left-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-intro-left-thm"><h3>or-intro-left-thm</h3><div class="usage"><code>(or-intro-left-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (or A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical disjunction. This is the introduction by the left operand.</p></div></div></div><div class="public anchor" id="var-or-intro-right"><h3>or-intro-right</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-intro-right left-type right-term)</code></p>
<p>Right introduction for disjunction, an implicit version of <a href="latte.prop.html#var-or-intro-right-thm">or-intro-right-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-intro-right-thm"><h3>or-intro-right-thm</h3><div class="usage"><code>(or-intro-right-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; B (or A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical disjunction. This is the introduction by the right operand.</p></div></div></div><div class="public anchor" id="var-or-not-elim-left"><h3>or-not-elim-left</h3><div class="usage"><code>(or-not-elim-left [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (not B) A)
</code></pre>
<p><strong>Theorem</strong>: An elimination rule for disjunction, simpler than <a href="latte.prop.html#var-or-elim">or-elim</a>. This eliminates to the left operand.</p></div></div></div><div class="public anchor" id="var-or-not-elim-right"><h3>or-not-elim-right</h3><div class="usage"><code>(or-not-elim-right [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (not A) B)
</code></pre>
<p><strong>Theorem</strong>: An elimination rule for disjunction, simpler than <a href="latte.prop.html#var-or-elim">or-elim</a>. This eliminates to the right operand.</p></div></div></div><div class="public anchor" id="var-or-not-impl-elim"><h3>or-not-impl-elim</h3><div class="usage"><code>(or-not-impl-elim [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (==&gt; (not A) B))
</code></pre>
<p><strong>Theorem</strong>: An alternative elimination rule for disjunction.</p></div></div></div><div class="public anchor" id="var-or-sym"><h3>or-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-sym or-term)</code></p>
<p>Symmetry of disjunction, an implicit version of <a href="latte.prop.html#var-or-sym-thm">or-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-sym-thm"><h3>or-sym-thm</h3><div class="usage"><code>(or-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (or B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of disjunction.</p></div></div></div><div class="public anchor" id="var-or-unparser"><h3>or-unparser</h3><div class="usage"><code>(or-unparser term)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-truth"><h3>truth</h3><div class="usage"><code>(truth)</code></div><div class="doc"><div class="markdown"><pre><code>(not absurd)
</code></pre>
<p><strong>Definition</strong>: Logical truth.</p></div></div></div><div class="public anchor" id="var-truth-is-true"><h3>truth-is-true</h3><div class="usage"><code>(truth-is-true)</code></div><div class="doc"><div class="markdown"><pre><code>truth
</code></pre>
<p><strong>Theorem</strong>: The truth is true (really ?).</p></div></div></div></div></body></html>